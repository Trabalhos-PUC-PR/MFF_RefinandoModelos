# -*- coding: utf-8 -*-
"""4 - Python - Numpy- Introdução.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S_B7evC-4aTQrI3GLsQX8MYLUoGXdTEh

# Numpy -  introdução aos arrays em numpy 
## Por Frank de Alcantara

## Introdução

A biblioteca numpy fornece um grande número de funções numéricas referentes a manipulaçao de vetores, matrizes e tensores. Trata-se de uma biblioteca de objetos, métodos e tipos de dados específicamente desenvolvida para uso em computação científica, cálculo numérico e álgebra linear que encontrou um nicho em aplicações de algoritmos de aprendizagem de máquina. Sua documentação pode ser encontrada em: [numpy](https://docs.scipy.org/doc/)
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt #apenas para os gráficos
import numpy as np
print("passamos aqui!!!")

"""Assim como em C, usamos array como denominação para vetores, matrizes e tensores na biblioteca `numpy`. Só para recordar: um array é uma estrutura de dados que mantém um conjunto de dados de um determinado tipo, e permite que um determinado elemento seja armazenado, localizado e alterado.

Na biblioteca numpy existe um tipo de dados _N-dimensional array (ndarray)_ que foi desenvolvido como um conteiner de objetos para definir uma estrutura de dados composta fundamental para representação de dados. Consiste, na maior parte das vezes, de uma coleção de dados, de tamanho fixo, do mesmo tipo, mantida em memória. 

Como todos os conteiners, os _ndarrays_ permitem que os elementos armazenados possam ser acessados, modificados, e inseridos. Existe, na verdade, um conjunto de métodos que permite um grande número de operações com os dados armazenados. 

No estudo de algoritmos de aprendizado de máquina iremos dar preferência ao array _ndarray_ definido na biblioteca numpy por que:

* As listas em Python são genéricas e podem conter qualquer tipo de objeto. Além disso, estas listas são dinâmicamente tipadas. Por fim, o Python não fornece, nativamente, as operações matemáticas básicas para a operação com vetores e matrizes;
* Por outro lado os ndarrays são **estaticamente tipadas**, homogêneas e seu tipo é definido na criação;
* Graças aos tipos estáticos, é possível implementar funções matemáticas extremamente rápidas e eficiente.

## Criando seu primeiro array

Existem, como não poderia deixar de ser, diversas formas de criar um array:

* por meio de uma lista de tuplas;
* usando funções especiais como: `arange`, `linspace`, etc.
* lendo dados de arquivos.

## Usando listas para criar um array
Podemos começar usando a função ___numpy.array___ e uma lista. Como no cabeçalho definimos a importação da biblioteca numpy como: ___import numpy as np___ poderemos utilizar ___np.array___
"""

# o vetor [1,2,3,4] será diretamene passado como argumento da função array. Este vetor é uma lista.
meuArray1 = np.array([1,2,3,4])
#para ver o ndarray criado. Lembre-se este array será mantido em memória.
meuArray1

"""Podemos ver o tipo da variável meu_array1"""

type(meuArray1)

"""Este **ndarray** significa **N-Dimensional Array** indicando que o tipo do array criado pelo numpy é multidimensional (n)"""

# ou podemos usar uma lista de listas como argumento da função array
meuArray2 = np.array([[1, 2], [3, 4], [7,8]])
#para ver a matriz criada. Observe que a matriz é um ndarrayb multidimensional.
meuArray2

"""O objeto **ndarray** criado armazena dados de um único tipo, independente do número de dimensões que armazenamos. Podemos usar o método ___type()___ para explicitar que método é este."""

#agora podemos ver o tipo dos objetos ndarray criados até o momento
type(meuArray1), type(meuArray2)

"""Além das funções que o objeto _numpy_ irá disponibilizar, há uma outra grande vantagem em usar este tipo de array. O objeto _numpy_ usa muito pouca memória se comparado ao array do Python. """

import sys ## para avaliar o tamanho de objetos na memória

lista_python = [1,2,3,4,5,6]
tamanho_lista = sys.getsizeof(1) * len(lista_python)
tamanho_lista

npArray = np.array([1,2,3,4,5,6])
tamanho_npArray = npArray.itemsize * npArray.size
tamanho_npArray

"""O objeto _ndarray_ possui um conjunto interessante de métodos que são informativos. Por exemplo, a diferença entre `meu_array1` e `meu_array2` é a sua forma. para descobrir a forma de um objeto podemos usar a propriedade `nomeDoArray.shape`."""

#descobrindo a forma do array. observe que este array tem apenas uma dimensão, trata-se de um vetor
print(meuArray1)
meuArray1.shape

#Já o meu_array2 tem duas dimensões e armazena uma matriz de 2X2
print(meuArray2)
meuArray2.shape

"""Outra propriedade informativa interessante do objeto _ndarray_ é a propriedade 'size' que pode ser acessada por: `nomeDoArray.size`."""

#determinando o tamanho de um ndarray
print(meuArray1.size)
print(meuArray2.size)

"""É importante notar que, a nível estrutural um array é apenas um conjunto de ponteiros que representa o resultado entre um tipo de dado, um fomato, um endereço de memória e um conjunto de passos: 
* O ponteiro indica o endereço de memória do primeiro byte do array;
* O tipo de dado, ou ___dtype___ descreve o tipo de ado usado pelos elementos do array;
* O formato é, ou ___shape___ óbviamente, a forma do array; 
* O conjunto de passos, ou ___strides___ representa apenas o número de bytes que precisam ser pulados na memória para que seja possível encontrar o próximo elemento. 

"""

#o tipo de dado que está armazenando no array do meu_Array2
meuArray2.dtype

"""Como são os objetos armazenados em um _ndarray_ são estáticamente tipados, não podemos acessar tipos de dados diferentes do tipo de dados que foi usado durante a criação do objeto. Existem 19 tipos de dados primitivos que podem ser armazenados em um objeto do tipo _ndarray_ estes tipos vão deste inteiros até números complexos passando por todos os tipos suportados pela linguagem Python."""

#esta linha, quando executada, terá que emitir um erro já que existe um erro de tipos na atribuição
meuArray2[0,0] = "hello"

"""Se você desejar, poderá criar um tipo de dado explicitamente usando o método ___np.array()___ com o argumento `dtype`. Podemos exemplificar este processo criando um novo array para armazenar números complexos. Por exemplo, para armazenar números complexos teremos:"""

#para trabalhar com números complexos
meuArray2 = np.array([[1, 2], [3, 4]], dtype=complex)
#para visualizar o novo array
meuArray2

"""## Usando funções para trabalhar com _ndarrays_
A biblioteca numpy fornece um conjunto interessante de métodos para facilitar os processos de criação e manutenção de _ndarrays_. Entre este métodos destacam-se: ___arange()___; ___linspace()___ e ___logspace()___
### Usando arange()
Este método permite a criação de um ndarray já populado por um conjunto de valores 

"""

# criando um array em um determinado range de valores
testeArange = np.arange(0, 10, 1) # argumentos: start, stop, step
testeArange

testeArange = np.arange(-1, 1, 0.1)

testeArange

"""### Usando linspace() e logspace()
Podemos usar estes métodos para criar um array com elementos distribuidos segundo um espaço determinado entre dois limites especificados. 

___np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)___

* ___start___: indica o limite inicial do intervalo;
* ___stop___: indica o limite final do intervalo;
* ___num___: indica o número de pontos que o intervalo deve conter. Inclui os pontos que representam os limites do intervalo.
* ___endpoint___: quando ___false___ o conjunto retornado não contém o limite final do intervalo.
* ___retstep___: se ___true___, o valor retornado é uma tupla em que o primeiro elemento é o arranjo construído, e o segundo elemento é o tamanho do intervalo.

"""

#a distribuição é linear
np.linspace(0, 10, 25)

"""Ou podemos criar um array com cinco valores entre $-\pi$ e $\pi$ sem o valor final ainda usando uma distribuição linear entre estes elementos. A constante $\pi$ está disponível tanto na biblioteca _math_ quanto na biblioteca _numpy_."""

np.linspace(-np.pi, np.pi, 25)

"""Usando o método logspace podemos fazer a mesma coisa distribuido os valores em um espaço logarítmico. 

___numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)___

Neste caso temos um argumento extra: ___base___ que representa a base do espaço logarítmo que será gerado o padrão é 10.0
"""

# usando logspace a distribuição é logarítmica
np.logspace(0, 10, 10, base=np.e)

"""### Usando dados randômicos
A biblioteca numpy usa um poderoso gerador de números psedo aleatórios conhecido como [Mersenne Twister](file:///C:/Users/Lab/Downloads/Jag08.pdf)

O método ___numpy.random.randn(d0, d1, …, dn)___ : irá criar um array com a forma especificada peor _(d0, d1,..., dn)_ e preencher este array com valores aleatórios de acordo com uma distribuição normal.  Se _(d0, d1, ..., dn)_ forem números positivos os números fornecidos estarão entre zero e um com média 0 e variância 1, se um dos argumentos for um float ele será convertido para inteiro por truncamento. Se nenhum argumento for fornecido o método devolverá um únio float randômico de acordo com a distribuição normal. 
"""

#podemos gerar um array com 4 elementos randômicos
np.random.normal(size=14)

# ou gerar uma matriz de 5X5
np.random.rand(5,5)

"""Você também pode mudar a distribuição de probabilidade para a geração de números randômicos. Se você não especificar a distribuição será usada a distribuição normal mas, existem 35 distribuições disponíveis na biblioteca Numpy. 

A distribuição normal recebe comp parâmetros:

*__Loc__ : float ou array de floats representando a média (centro) da distribuição;

*__scale__ : float ou array de floats representando o desvio padrão da distribuição;

*__size__ : opcional um inteiro ou uma tupla de inteiros representando o formato do array de saida. 


A distribuição normal devolve:	

*__out__ : um array do numpy (ndarray) ou um escalar

Essa a densidade de probabilidade de uma Gaussiana é dada por: 
$$P(x) = \frac{1}{\sqrt{2\pi\sigma^2}}\epsilon^{\frac{(x-\mu)^2}{2\sigma^2}}$$
Onde $\mu$ representa a média e $\sigma$ representa o desvio padrão.

usando o matplotlib é possivel plotar uma distribuição normal de números randômicos.
"""

media, desvio = 0, 0.4 
universo = np.random.normal(media, desvio, 500)

contador, faixas, ignorar= plt.hist(universo, 30, density=True)
#aplicando a fórmula diretamente na função de plotagem
plt.plot(faixas, 1/(desvio * np.sqrt(2 * np.pi)) *
          np.exp( - (faixas - media)**2 / (2 * desvio**2) ),
          linewidth=2, color='b')
#finalmente plotamos
plt.show()

"""Podemos também, apenas como exemplo, gerar números randômicos de acordo com uma distribuição uniform. Neste caso, teremos os seguintes
argumentos: 

*__Low__: float ou array de floats representando a borda inferior do intervalo de saída;

*__high__: float ou array de floats representando a borda superior do intervalo de saída; 

*__size__: interior ou tupla de inteiros representado o formato da saída.

E irá resultar em um array do numpy (ndarray) ou um escalar. 

O método ___uniform___ devolverá um conjunto de números randômicos em um intervalo fechado na borda inferior e aberto na borda superior.
Isso quer dizer que o argumento __Low__ será incluído no conjunto de resposta. A distribuição uniforme é dada por:

$$p(x) = \frac{1}{b - a}$$

E podemos, novamente, plotar um diagrama para entender essa distribuição


"""

universo = np.random.uniform(-1,0,500)

contador, faixa, ignorar = plt.hist(universo, 55, density=True)
# O método np.ones_like devolve um array de 1 com a mesma forma do array fornecido como argumento
plt.plot(faixa, np.ones_like(faixa),linewidth=2, color='r')
plt.show()

"""A função ___np.random.randint___ permite a geração de um conjunto de números randômicos inteiros no intervalo definido por __low__ (fechado) e __high__ (aberto). dois limites, o inferior e o superior. O terceiro argumento determina a forma do array resultante. """

#gerando um array de inteiros randômicos entre 1 e 20 com comprimento 8
np.random.randint(low=1, high=20, size=8)

"""Há ainda um quarto argumento para a função ___np.random.randint___ este argumento permite determinar o ___dtype___ do array (ndarray) resultante por seu nome: ‘int64’, ‘int’, etc, o valor default é ‘np.int’.

"""

#gerando números randomicos inteiros do tipo int64 entre 3 (incluído) e 10 (excluído) em uma matriz de 5X5
np.random.randint(3, 10, size=(5, 5), dtype='int32')

"""### Criando uma matrix diagonal """

# a  matriz diagonal com valores 1,2,3 
np.diag([1,2,3])

# uma matriz diagonal com uma coluna e linha deslocadas
np.diag([1,2,3], k=1)

"""#### Criando matrizes de zeros and uns"""

np.zeros((3,3))

np.ones((3,3))

"""## Manipulando Arrays

### Index
"""

#Muito parecdido com a linguagem C
print(meuArray1)
meuArray1[0]

print(meuArray1)

meuArray1[3]

# se usarmos dois índices....
print(meuArray2)
meuArray2[1,0]

print(meuArray2)
meuArray2[1,:] # ou explicitamente declarar uma linha : row 1

print(meuArray2)
meuArray2[:,1] # ou uma coluna

"""Também podemos atribuir valores usando o índice:"""

meuArray2 = np.array([[9, 8], [7, 6]])
print(meuArray2)
meuArray2[0,0] = 1
print("\n",meuArray2)

print(meuArray2,"\n")
# o que também funciona para linhas e colunas
meuArray2[1,:] = 0 # segunda linha toda de zeros
print(meuArray2,"\n")
meuArray2[:,1] = -1 #segunda coluna toda de -1
print(meuArray2)

"""### Extraíndo dados do array

podemos usar a sintaxe `M[lower:upper:step]` para extrari partes do array. Vamos criar o array A:
"""

meuArray1 = np.array([1,2,3,4,5])
meuArray1

#e retirar o array que está entre os índices 1 (incluído) e 3 (excluído)
novoArray1 = meuArray1[1:3]
novoArray1

"""Podemos usar a mesam sintaxe para atribuir valores a um range de indexes."""

meuArray1[1:3] = [-2,-3]

meuArray1

"""Podemos trabalhar essa sintaxe em busca de valores diferentes, ainda usando os índices. """

meuArray1[::] # tudo ignorado, usando os valores default

print(meuArray1)
meuArray1[::2] # mudando apenas o atributo step para 2

meuArray1[:3] # os três primeiros elementos

meuArray1[3:] # todos os elementos a partir do índice 3

"""Índices podem ser negativos, e positivos. Os índices negativos contam do final para o começo do array. E não existe índice -zero."""

meuArray1 = np.array([1,2,3,4,5])

meuArray1[-1] # retorna o último elemento do array

meuArray1[-3:] # retorna os três últimos

"""## Funções Matemáticas """

print(meuArray1)

print("O maior valor é", meuArray1.max())      #O maior valor de um array
print("O índice do maior valor é", meuArray1.argmax())   #O índice do array onde está o maior valor
print("O menor valor é", meuArray1.min())      #O menor valor de um array
print("O índice do menor valor é", meuArray1.argmin())   #O índice do array onde está o menor valor

foo = np.array([[4,3], [1,0]])
print("foo:\n", foo)
bar = np.array([[1,2], [3,4]])
print("bar:\n",bar)
print("foo+bar:\n ", foo+bar) #adição
print("foo-bar:\n ", foo-bar) #subtração
print("foo*bar:\n ", foo*bar) #multiplicação
print("foo/bar:\n ", foo/bar) #divisão
print("foo@bar:\n ", foo@bar) #Multiplicação de Matrizes
print("foo+5:\n ", foo+5) #adição
print("foo-5:\n ", foo-5) #subtração
print("foo*5:\n ", foo*5) #multiplicação
print("foo/5:\n ", foo/5) #divisão

matriz = np.array(
    [[5.0, 2.0, 10.0],
     [1.0, 0.0, 7.0],
     [1.0, 7.0, 5.0]]
)
print(matriz)

"""Podemos somar todos os elementos de um array"""

np.sum(matriz)

"""Também podemos somar por colunas"""

print("Por colunas:", np.sum(matriz, axis = 0)) #axis = 0 = somar por colunas

print("Por linhas:", np.sum(matriz, axis = 1)) #axis = 0 = somar por linhas

print(matriz)
print("indexando")
print("linha 0:", matriz[0])
print("linha 1:", matriz[1])
print("linha 2:", matriz[2])

"""As coisas incríveis que fazemos com índices"""

print(matriz)
print("indexando")
print("Coluna 0:", matriz[:,0])
print("Coluna 1:", matriz[:,1])
print("Coluna 2:", matriz[:,2])

print("Linha 1, Coluna 2:", matriz[1,2])